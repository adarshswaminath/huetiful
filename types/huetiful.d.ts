// Generated by dts-bundle-generator v8.1.2

/*
 * @preserve
 * @license
 * types.d.ts - Type declarations for huetiful-js.
 * Contains colors from TailwindCSS released under the MIT permissive licence.
Copyright 2023 Dean Tarisai.
This file is licensed to you under the Apache License, Version 2.0 (the 'License');
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an 'AS IS' BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License.
*/
// Color token types
export type ColorTuple = [
	string,
	number,
	number,
	number,
	number?
];
export type ColorOptions = {
	alpha?: number;
	lightness?: number;
	temperature?: number;
	colorspace?: HueColorSpaces;
	luminance?: number;
	saturation?: number;
	lightMode?: ColorToken;
	darkMode?: ColorToken;
	contrast?: number;
	colorSpace?: HueColorSpaces;
};
export type ColorDistanceOptions = {
	weights?: [
		number,
		number,
		number,
		number
	];
	mode?: Colorspaces;
};
export type InterpolatorOptions = Pick<Options, "easingFunc" | "hueInterpolator" | "chromaInterpolator" | "hueFixup" | "lightnessInterpolator">;
/**
 * @type
 * @description The override parameters for palette functions.
 */
export type Options = {
	/**
	 * The easing function to use.
	 * @param t Any value between 0 and 1
	 * @returns A number.
	 */
	easingFunc?: (t: number) => number;
	/**
	 *@param The interpolation method to use on the hue channel.
	 */
	hueInterpolator?: Interpolator;
	/**
	 *@param The interpolation method to use on the chroma channel.
	 */
	chromaInterpolator?: Interpolator;
	/**
	 *@param The type of hue fixup to apply to the hue channels during interpolation.
	 */
	hueFixup?: (arr: number[]) => number[];
	/**
	 *@param The interpolation method to use on the lightness channel.
	 */
	lightnessInterpolator?: Interpolator;
	/**
	 *@param The color to pass through during interpolation.
	 */
	via?: Tone;
	/**
	 *@param The amount of hue angles to increment each iteration with.
	 */
	hueStep?: number;
	/**
	 * * @param earthtone The earthtone to interpolate with.
	 */
	earthtones?: "light-gray" | "silver" | "sand" | "tupe" | "mahogany" | "brick-red" | "clay" | "cocoa" | "dark-brown" | "dark";
	/**
	 *@param The amount of samples to return in the result collection.
	 */
	samples?: number;
	/**
	 * * @param minLightness  Minimum lightness value (range 0-100).
	 */
	minLightness?: number;
	/**
	 * @param maxLightness  Maximum lightness value (range 0-100).
	 */
	maxLightness?: number;
};
export type PairedSchemeOptions = Omit<Options, "earthtones" | "maxLightness" | "minLightness">;
export type HueShiftOptions = Omit<Options, "via" | "earthtones" | ""> & InterpolatorOptions;
export type Interpolator = (arr: number[]) => (t: number) => number;
export type Tone = "light" | "dark";
export type DeficiencyType = "red" | "blue" | "green" | "monochromacy";
export type HueFamily = "red-purple" | "red" | "yellow-red" | "yellow" | "green-yellow" | "green" | "blue-green" | "blue" | "purple-blue" | "purple";
export type DivergingScheme = "Spectral" | "RdYlGn" | "RdBu" | "PiYG" | "PRGn" | "RdYlBu" | "BrBG" | "RdGy" | "PuOr";
export type QualitativeScheme = "Set2" | "Accent" | "Set1" | "Set3" | "Dark2" | "Paired" | "Pastel2" | "Pastel1";
export type SequentialScheme = "OrRd" | "PuBu" | "BuPu" | "Oranges" | "BuGn" | "YlOrBr" | "YlGn" | "Reds" | "RdPu" | "Greens" | "YlGnBu" | "Purples" | "GnBu" | "Greys" | "YlOrRd" | "PuRd" | "Blues" | "PuBuGn" | "Viridis";
/**
 * @type
 * @description Any recognizable color token.
 */
export type ColorToken = number | string | object | ColorTuple;
/**
 * @param
 * An array of baseColor tokens (in short, just an array of valid colors)
 */
/**
 * @type
 * The property being queried. Used in utilities that perform operations on collections.
 */
export type Factor = "luminance" | "temp" | "saturation" | "contrast" | "distance" | "lightness" | "hue" | string;
export type Order = "asc" | "desc";
export type callback = unknown;
export type UniformColorSpaces = "lch" | "jch" | "dlch" | "lch" | "lch65" | "lchuv" | "oklch" | string;
export type Colorspaces = "a98" | "cubehelix" | "dlab" | "jab" | "lab" | "lab65" | "lrgb" | "luv" | "oklab" | "rgb" | HueColorSpaces;
export type HueColorSpaces = UniformColorSpaces | "hsl" | "hsv" | "hsi" | "hwb" | "okhsl" | "okhsv";
export type ScaleValues = "50" | "100" | "200" | "300" | "400" | "500" | "600" | "700" | "800" | "900";
export type TailwindColorFamilies = "indigo" | "gray" | "zinc" | "neutral" | "stone" | "red" | "orange" | "amber" | "yellow" | "lime" | "green" | "emerald" | "teal" | "sky" | "blue" | "violet" | "purple" | "fuchsia" | "pink" | "rose";
/**
 * @internal
 *  Returns the first truthy value.
 * @param arg The value to check
 * @param def The value to cast if arg is falsy
 * @returns The first truthy value
 */
export declare function checkArg(arg: unknown, def: unknown): unknown;
export declare const interpolatorConfig: {
	easingFunc: (t: number) => number;
	chromaInterpolator: Interpolator;
	hueFixup: (arr: number[]) => number[];
	hueInterpolator: Interpolator;
	lightnessInterpolator: Interpolator;
};
/**
 * @internal
 *  Gets the clipped string of a passed in colorspace by removing non-channel characters.
 * @param colorspace  The colorspace to get the channel keys.
 * @param index Optional index to return a single specified channel.
 * @returns A string.
 *
 @example

 console.log(getModeChannel("oklch"));
// lch

console.log(getModeChannel("okhsl", 2));
// l

 */
export declare function getModeChannel(colorspace: Colorspaces | string, index?: number): string;
/**
 * @internal
 * Takes an arithmetic operator followed by a value and passes the result of the expression to the specified channel. Currently supports addition,subtraction,division and multiplication symbols only.
 * @param color The color.
 * @param modeChannel The colorspace channel to set.
 * @param expression The expression assignment as a string.
 * @example
 *
 * console.log(lch('blue'));
// { mode: 'lch',l: 29.568297153444703,c: 131.2014771995311,h: 301.36428148973533}

console.log(expressionParser('blue', 'lch.l', '*0.3'));
// { mode: 'lch',l: 8.87048914603341,c: 131.2014771995311,h: 301.36428148973533 }

 */
export declare function expressionParser(color: ColorToken, modeChannel: string, expression: string): number;
/**
 * @internal
 * @function
 * Matches the chroma/saturation channel of any compliant color space
 * @param colorspace The color space to match saturation/chroma channel. Default is Lch
 * @returns The mode channel string passed to getChannel()
 * @example
 *
 * import { matchChromaChannel } from 'huetiful-js'
 * console.log(matchChromaChannel("jch"));
// jch.c

console.log(matchChromaChannel("okhsl"));
// okhsl.s
 */
export declare function matchChromaChannel(colorspace: HueColorSpaces | string): string;
/**
 * @internal
 * @function
 * Matches the lightness channel of any compliant color space
 * @param colorspace The color space to match lightness channel. Default is Lch
 * @returns The mode channel string passed to getChannel
 *
 * @example
 *
 * console.log(matchLightnessChannel("jch"));
// jch.j

console.log(matchLightnessChannel("okhsl"));
// okhsl.l
 */
export declare function matchLightnessChannel(colorspace: HueColorSpaces | string): string;
/**
 *
 * @param factor The factor being queried
 * @param callback The function to compute the factor value. It must have an arity of one and take a color as its argument.
 * @example

 let col = 'purple';
console.log(colorObj('saturation', getChannel('lch.c'))(col));
// { saturation: 66.82572352143816, color: 'purple' }

 */
export declare function colorObj(factor: Factor, callback: callback): (color: ColorToken) => {
	[x: string]: any;
	color: ColorToken;
};
/**
 * @internal
 * @param collection The collection to inspect.
 * @param predicate The function invoked per iteration.
 * @param factor The value to compare against
 * @returns Returns the found element or its key, else `undefined`.
 */
export declare function customFindKey(collection: object, factor: number): string;
export declare function customConcat(hue: object): number[];
/**
 * @internal
 *
 * @param value The hue angle to normalize.
 * @returns The normalized hue angle or passed in value if it was within [0,360]
 *
 * @example
 *
 * console.log(adjustHue(4));
// 4

console.log(adjustHue(444));
// 84
 */
export declare function adjustHue(value: number): number;
/**
 * @internal
 * Returns the channel value difference between the passed in colors. They are both converted to the colorspace in the modeChannel parameter before values are computed.
 * @param color The color to subtract values from/
 * @param modeChannel The colorspace and channel string to perform the operation in.
 * @example
 *
console.log(channelDifference('blue', 'okhsl.l')('pink'));
// 0.4794739863155694
 *
 */
export declare function channelDifference(color: ColorToken, modeChannel: string): (subtrahend: ColorToken) => number;
/**
 * Checks if x is greater than y
 * @param x The value to compare
 * @param y The value to compare against
 * @returns True if x is greater than y else false.
 *
 * @example
 *
 * gt(5,10)
 * // false
 */
export declare function gt(x: number, y: number): boolean;
/**
 * Checks if x is less than y.
 * @param x The value to compare
 * @param y The value to compare against
 * @returns True if x is less than y else false.
 *
 * @example
 * lt(2,8)
 * // true
 */
export declare function lt(x: number, y: number): boolean;
/**
 * Checks if x is greater than or equal to y.
 * @param x The value to compare
 * @param y The value to compare against
 * @returns True if x is greater than or equal to x else false.
 *
 * @example
 * gte(5,5)
 * // true
 *
 * gte(6,5)
 * // true
 *
 * gte(4,5)
 * // false
 */
export declare function gte(x: number, y: number): boolean;
/**
 * Checks if x is less than or equal to y.
 * @param x The value to compare
 * @param y The value to compare against
 * @returns True if x is less than or equal to y else false.
 *
 * @example
 *
 * lte(5,5)
 * // true
 *
 * lte(6,5)
 * // false
 *
 * lte(4,5)
 * // true
 */
export declare function lte(x: number, y: number): boolean;
/**
 * Checks if x is equal to y
 * @param x The value to compare
 * @param y The value to compare against
 * @returns True if x is equal to y else false.
 *
 * eq(4,5)
 * // false
 */
export declare function eq(x: number, y: number): boolean;
/**
 * Checks if x is not equal to y. The inverse of `eq`
 * @param x The value to compare
 * @param y The value to compare against
 * @returns True if x is not equal to y else false.
 *
 * @example
 * neq(5,5)
 * // false
 *
 * neq(4,5)
 * // true
 */
export declare function neq(x: number, y: number): boolean;
/**
 * @internal
 * Checks if a value is within the start and end range.
 * @param number The number to check.
 * @param start The minimum or starting value.
 * @param end The maximum or starting value.
 * @returns True if the number is in range else false.
 *
 * @example
 *
 * inRange(5,6,10)
 * // true
 *
 * inRange(-3,0)
 * // false
 */
export declare function inRange(number: number, start: number, end?: number): boolean;
/**
 * @internal
 * Checks if a number is an integer or float.
 * @param num The number to query
 * @returns True if the number is an integer else false if it is a float.
 *
 * @example
 *
 * isInteger(2)
 * // true
 *
 * isInteger(2.01)
 * // false
 */
export declare function isInteger(num: number | string): boolean;
/**
 * @internal
 * Normalizes passed in channel value to a range accepted by color spaces as defined in Culori.
 * @param value The value to chec if its in the accepted range for the passed in mode channel
 * @param modeChannel A string defining the mode and channel ranges to use for comparison
 * @returns The normalized channel value or the passed in value if it was within range
 *
 */
export declare function normalize(value: number, modeChannel: string): number;
/**
 * @internal
 * Returns a random number between minimum and maximum bounds.
 * @param min The lower bound.
 * @param max The upper bound.
 * @returns A number.
 *
 * @example
 *
 * random(5,15)
 * // 6
 */
export declare function random(min: number, max: number): number;
/**
 * @internal
 * Rounds up or down a number based on the float value.
 * @param num The number to round up or down.
 * @returns An integer
 * @example
 *
 * console.log(floorCeil(1.45));
// 1
console.log(floorCeil(1.501));
// 2

 */
export declare function floorCeil(num: number): number;
/**
 * @internal
 * Helper function for native sorting method for arrays.
 * @param factor The property to query.
 * @param order Either ascending or descending.
 * @returns A sorted array.
 */
export declare function customSort(order: Order, factor?: Factor | string): (a: {
	[x: string]: number;
}, b: {
	[x: string]: number;
}) => number;
export declare function colorObjArr(factor: Factor, callback: any): (collection: ColorToken[] | object | object) => Array<{
	factor: Factor;
	color: ColorToken;
}>;
/**
 * @internal
 *  Gets the smallest value in an array
 * @param array The array to retrieve minimum value
 * @returns The smallest number in the array
 * @example
 * console.log(min([0, 3, 4]));
// 0
 *
 */
export declare function min(array: number[]): number;
/**
 * @internal
 *  Gets the largest value in an array
 * @param array The array to retrieve maximum value
 * @returns The largest number in the array
 * @example
 * console.log(max([0, 3, 4]));
// 4
 */
export declare function max(array: number[]): number;
/**
 * @internal
 * Gets the digits in the expression string
 * @param s The string to match
 * @returns The matched digits, if any, as a number.
 */
export declare function matchDigits(s: string): number;
/**
 * @internal
 * Matches the comparison symbols used in the expression string.
 * @param s The string to match.
 * @returns The matched comparator, if any, as a string.
 */
export declare function matchComparator(s: string): string;
/**
 * @internal
 *  Filters an array of color objects with a "factor"  property whose value is determined by a predicate or getter via the cb param.
 * @param factor The property to query
 * @param callback The function to use for comparison.
 * @returns An array of colors or color objects.
 */
export declare function sortedArr(factor: Factor, callback: callback, order: Order, colorObj?: boolean): (collection: ColorToken[] | object) => any[];
/**
 * @internal
 *  Filters an array according to the value of a color's queried factor
 * @param factor The property to query and use as filtering criteria
 * @param cb The function to use for comparison
 * @returns The filtered array
 */
export declare function filteredArr(factor: Factor, cb?: callback): (collection: ColorToken[] | object, start: number | string, end?: number) => ColorToken[];
export declare class ColorArray {
	constructor(colors: ColorToken[]);
	/**
	 *
	 *  Returns a spline based interpolator function with customizable interpolation methods (passed in as 'kind') and optional channel specific overrides.If a color has a falsy channel for example black has an undefined hue channel some interpolation methods may return NaN affecting the final result.
	 * @param colorspace The colorspace to perform the interpolation in. Prefer uniform color spaces for better results such as Lch or Jch.
	 * @param kind The type of the spline interpolation method. Default is basis.
	 * @param closed Optional parameter to return the `closed` variant of the `kind` of interpolation method which can be useful for cyclical color scales. Default is false
	 * @param options Optional channel specific overrides.
	 * @returns A hexadecimal representation of the resultant color.
	 */
	interpolateSpline(colorspace?: HueColorSpaces, samples?: number, kind?: "natural" | "monotone" | "basis", closed?: boolean, options?: InterpolatorOptions): ColorToken[];
	/**
   *
   *  Takes an array of colors and finds the best matches for a set of predefined palettes. The function does not work on achromatic colors, you may use isAchromatic to filter grays from your collection before passing it to the function.
   * @param schemeType (Optional) The palette type you want to return.
   * @returns An array of colors if the scheme parameter is specified else it returns an object of all the palette types as keys and their values as an array of colors. If no colors are valid for the palette types it returns an empty array for the palette results.
   * @example
   *
   * import { discoverPalettes } from 'huetiful-js'
  
  let sample = [
	"#ffff00",
	"#00ffdc",
	"#00ff78",
	"#00c000",
	"#007e00",
	"#164100",
	"#720000",
	"#600000",
	"#4e0000",
	"#3e0000",
	"#310000",
  ]
  
  console.log(load(sample).discoverPalettes(sample, "tetradic").output())
  // [ '#ffff00ff', '#00ffdcff', '#310000ff', '#720000ff' ]
   */
	discoverPalettes(schemeType?: "analogous" | "triadic" | "tetradic" | "complementary"): ColorToken[] | object;
	/**
   *
   *  Gets the largest hue value from the passed in colors.
   * @param colorSpace The mode color space to perform the computation in.
   * @param colorObj Optional boolean that makes the function return a custom object with factor (hue) and name of the color as keys. Default is false.
   * @returns The largest hue value in the colors passed in or a custom object.
   * @example
   *
   * import { getFarthestHue } from 'huetiful-js'
  let sample = ['b2c3f1', '#a1bd2f', '#f3bac1']
  
  console.log(load(output).getFarthestHue('lch'))
  // 273.54920266436477
   */
	getFarthestHue(colorSpace?: HueColorSpaces, colorObj?: boolean): number | {
		factor: number;
		color: ColorToken;
	};
	/**
   *
   *  Gets the smallest hue value from the passed in colors.
   * @param colors The array of colors to query the color with the smallest hue value.
   * @param colorSpace The mode color space to perform the computation in.
   * @param colorObj Optional boolean that makes the function return a custom object with factor (hue) and name of the color as keys. Default is false.
   * @returns The smallest hue value in the colors passed in or a custom object.
   * @example
   *
   * import { getNearestHue } from 'huetiful-js'
  
  let sample = ['b2c3f1', '#a1bd2f', '#f3bac1']
  
  console.log(load(sample).getNearestHue('lch'))
  // 12.462831644544274
   */
	getNearestHue(colorSpace?: HueColorSpaces, colorObj?: boolean): number | {
		factor: number;
		color: ColorToken;
	};
	/**
   *
   *  Gets the smallest lightness value from the passed in colors.
   * @param colorObj Optional boolean that makes the function return a custom object with factor (lightness) and name of the color as keys. Default is false.
   * @returns The smallest lightness value in the colors passed in or a custom object.
   * @example
   *
   * import { minLightness } from 'huetiful-js'
  
  let sample = ["b2c3f1", "#a1bd2f", "#f3bac1"]
  
  console.log(load(sample).getNearestLightness('lch', true))
  
  // { lightness: 72.61647882089876, name: '#a1bd2f' }
  
   */
	getNearestLightness(colorspace?: HueColorSpaces, colorObj?: boolean): number | {
		factor: number;
		color: ColorToken;
	};
	/**
   *
   *  Gets the largest lightness value from the passed in colors.
   * @param colors The array of colors to query the color with the largest lightness value.
   * @param colorObj Optional boolean that makes the function return a custom object with factor (lightness) and name of the color as keys. Default is false.
   * @returns The largest lightness value in the colors passed in or a custom object.
   * @example
   *
   * import { maxLightness } from 'huetiful-js'
  
  let sample = ["b2c3f1", "#a1bd2f", "#f3bac1"]
  
  console.log(load(sample).getFarthestLightness('lch', true))
  
  // { lightness: 80.94668903360088, name: '#f3bac1' }
  
   */
	getFarthestLightness(colorspace?: HueColorSpaces, colorObj?: boolean): number | {
		factor: number;
		color: ColorToken;
	};
	/**
   *
   *  Returns an array of colors in the specified saturation range. The range is normalised to [0,1].
   * @param  startSaturation The minimum end of the saturation range.
   * @param  endSaturation The maximum end of the saturation range.
   * @param mode The color space to fetch the saturation value from. Any color space with a chroma channel e.g 'lch' or 'hsl' will do.
   * @returns Array of filtered colors.
   * @example
   * import { filterByContrast } from 'huetiful-js'
  
  let sample = [
	'#00ffdc',
	'#00ff78',
	'#00c000',
	'#007e00',
	'#164100',
	'#ffff00',
	'#310000',
	'#3e0000',
	'#4e0000',
	'#600000',
	'#720000',
  ]
  
  console.log(filterByContrast(sample, 'green', '>=3'))
  // [ '#00ffdc', '#00ff78', '#ffff00', '#310000', '#3e0000', '#4e0000' ]
   */
	filterBySaturation(startSaturation?: number, endSaturation?: number, mode?: HueColorSpaces): ColorArray;
	/**
   *
   *  Returns an array of colors in the specified lightness range. The range is between 0 and 100.
   * @param  startLightness The minimum end of the lightness range.
   * @param  endLightness The maximum end of the lightness range.
   * @returns Array of filtered colors.
   * @example
   *
   * import { filterByLightness } from 'huetiful-js'
  let sample = [
	'#00ffdc',
	'#00ff78',
	'#00c000',
	'#007e00',
	'#164100',
	'#ffff00',
	'#310000',
	'#3e0000',
	'#4e0000',
	'#600000',
	'#720000',
  ]
  
  filterByLightness(sample, 20, 80)
  
  // [ '#00c000', '#007e00', '#164100', '#720000' ]
   */
	filterByLightness(startLightness?: number, endLightness?: number): ColorArray;
	/**
   *
   *  Returns an array of colors with the specified distance range. The distance is tested against a comparison color (the 'against' param) and the specified distance ranges.
   * @param  startDistance The minimum end of the distance range.
   * @param  endDistance The maximum end of the distance range.
   * @param weights The weighting values to pass to the Euclidean function. Default is [1,1,1,0].
   * @param mode The color space to calculate the distance in .
   * @returns Array of filtered colors.
   * @example
   * import { filterByDistance } from 'huetiful-js'
  
  let sample = [
	"#ffff00",
	"#00ffdc",
	"#00ff78",
	"#00c000",
	"#007e00",
	"#164100",
	"#720000",
	"#600000",
  ]
  
  console.log(filterByDistance(sample, "yellow", 0.1))
  // [ '#ffff00' ]
   */
	filterByDistance(against: ColorToken, startDistance?: number, endDistance?: number): ColorArray;
	/**
	 *
   *
   *  Returns an array of colors with the specified contrast range. The contrast is tested against a comparison color (the 'against' param) and the specified contrast ranges.
   * @param  startContrast The minimum end of the contrast range.
   * @param  endContrast The maximum end of the contrast range.
   * @returns Array of filtered colors.
   *
   * @example
   *
   * import { filterByContrast } from 'huetiful-js'
  
  let sample = [
	'#00ffdc',
	'#00ff78',
	'#00c000',
	'#007e00',
	'#164100',
	'#ffff00',
	'#310000',
	'#3e0000',
	'#4e0000',
	'#600000',
	'#720000',
  ]
  
  console.log(filterByContrast(sample, 'green', '>=3'))
  // [ '#00ffdc', '#00ff78', '#ffff00', '#310000', '#3e0000', '#4e0000' ]
   */
	filterByContrast(against: ColorToken, startContrast?: number, endContrast?: number): ColorArray;
	/**
   *
   *  Returns colors in the specified hue ranges between 0 to 360.
   * @param  startHue The minimum end of the hue range.
   * @param  endHue The maximum end of the hue range.
   * @returns  Array of the filtered colors.
   * @example
   * let sample = [
	'#00ffdc',
	'#00ff78',
	'#00c000',
	'#007e00',
	'#164100',
	'#ffff00',
	'#310000',
	'#3e0000',
	'#4e0000',
	'#600000',
	'#720000',
  ]
  
  filterByHue(sample, 20, 80)
  
  // [ '#310000', '#3e0000', '#4e0000', '#600000', '#720000' ]
   */
	filterByHue(startHue?: number, endHue?: number): ColorArray;
	/**
   *
   *  Returns an array of colors in the specified luminance range. The range is normalised to [0,1].
   * @param  startLuminance The minimum end of the luminance range.
   * @param  endLuminance The maximum end of the luminance range.
   * @returns Array of filtered colors.
   * @example
   *
   * import { filterByLuminance } from 'huetiful-js'
  let sample = [
	'#00ffdc',
	'#00ff78',
	'#00c000',
	'#007e00',
	'#164100',
	'#ffff00',
	'#310000',
	'#3e0000',
	'#4e0000',
	'#600000',
	'#720000',
  ]
  
  filterByLuminance(sample, 0.4, 0.9)
  
  // [ '#00ffdc', '#00ff78' ]
   */
	filterByLuminance(startLuminance?: number, endLuminance?: number): ColorArray;
	/**
   *
   *  Sorts colors according to their lightness.
   * @param  colors The array of colors to sort
   * @param  order The expected order of arrangement. Either 'asc' or 'desc'. Default is ascending ('asc')
   * @returns An array of the sorted color values.
   * @example
   * import { sortByLightness } from "huetiful-js";
  
  let sample = [
	"#00ffdc",
	"#00ff78",
	"#00c000",
	"#007e00",
	"#164100",
	"#ffff00",
	"#310000",
	"#3e0000",
	"#4e0000",
	"#600000",
	"#720000",
  ]
  
  sortByLightness(sample)
  
  // [
	'#310000', '#3e0000',
	'#4e0000', '#600000',
	'#720000', '#164100',
	'#007e00', '#00c000',
	'#00ff78', '#00ffdc',
	'#ffff00'
  ]
  
  
  sortByLightness(sample,'desc')
  
  // [
	'#ffff00', '#00ffdc',
	'#00ff78', '#00c000',
	'#007e00', '#164100',
	'#720000', '#600000',
	'#4e0000', '#3e0000',
	'#310000'
  ]
  
   */
	sortByLightness(order?: "asc" | "desc"): ColorArray;
	/**
   *
   *  Sorts colors according to their Euclidean distance. The distance factor is determined by the color space used (some color spaces are not symmetrical meaning that the distance between colorA and colorB is not equal to the distance between colorB and colorA ). The distance is computed from against a color which is used for comparison for all the colors in the array i.e it sorts the colors against the dist
   * @param against The color to compare the distance with. All the distances are calculated between this color and the ones in the colors array.
   * @param  order The expected order of arrangement. Either 'asc' or 'desc'. Default is ascending ('asc')
   * @param weights The weighting values to pass to the Euclidean function. Default is [1,1,1,0].
   * @param mode The color space to calculate the distance in . The default is the cylindrical variant of the CIELUV colorspace ('lchuv')
   * @returns An array of the sorted color values.
   * @example
   * import { sortByDistance } from 'huetiful-js'
  
  let sample = ['purple', 'green', 'red', 'brown']
  console.log(
	sortByDistance(sample, 'yellow', 'asc', {
	  mode: 'lch',
	})
  )
  
  // [ 'brown', 'red', 'green', 'purple' ]
  
  let sample = ['purple', 'green', 'red', 'brown']
  console.log(
	sortByDistance(sample, 'yellow', 'asc', {
	  mode: 'lch',
	})
  )
  
  // [ 'green', 'brown', 'red', 'purple' ]
   */
	sortByDistance(against: ColorToken, order?: "asc" | "desc", options?: ColorDistanceOptions): ColorArray;
	/**
   *
   *  Sorts colors according to the relative brightness as defined by WCAG definition.
   * @param  colors The array of colors to sort
   * @param  order The expected order of arrangement. Either 'asc' or 'desc'. Default is ascending ('asc')
   * @returns An array of the sorted color values.
   * @example
   * import { sortByLuminance } from "huetiful-js";
  let sample = [
	"#00ffdc",
	"#00ff78",
	"#00c000",
	"#007e00",
	"#164100",
	"#ffff00",
	"#310000",
	"#3e0000",
	"#4e0000",
	"#600000",
	"#720000",
  ];
  
  
  
  let sorted = sortByLuminance(sample)
  console.log(sorted)
  // [
	'#310000', '#3e0000',
	'#4e0000', '#600000',
	'#720000', '#164100',
	'#007e00', '#00c000',
	'#00ff78', '#00ffdc',
	'#ffff00'
  ]
  
  let sortedDescending = sortByLuminance(sample, "desc");
  console.log(sortedDescending)
  // [
	'#ffff00', '#00ffdc',
	'#00ff78', '#00c000',
	'#007e00', '#164100',
	'#720000', '#600000',
	'#4e0000', '#3e0000',
	'#310000'
  ]
  
   
   */
	sortByLuminance(order?: "asc" | "desc"): ColorArray;
	/**
   *
   *  Sorts colors according to their saturation.
   * @param  colors The array of colors to sort
   * @param  order The expected order of arrangement. Either 'asc' or 'desc'. Default is ascending ('asc')
   * @param mode The mode color space to compute the saturation value in. The default is jch .
   * @returns An array of the sorted color values.
   * @example
   * import { sortBySaturation } from "huetiful-js";
  let sample = [
	"#00ffdc",
	"#00ff78",
	"#00c000",
	"#007e00",
	"#164100",
	"#ffff00",
	"#310000",
	"#3e0000",
	"#4e0000",
	"#600000",
	"#720000",
  ];
  
  let sorted = sortBySaturation(sample);
  console.log(sorted);
  
  // [
	'#310000', '#3e0000',
	'#164100', '#4e0000',
	'#600000', '#720000',
	'#00ffdc', '#007e00',
	'#00ff78', '#00c000',
	'#ffff00'
  ]
  
  let sortedDescending = sortBySaturation(sample,'desc');
  console.log(sortedDescending)
  // [
	'#ffff00', '#00c000',
	'#00ff78', '#007e00',
	'#00ffdc', '#720000',
	'#600000', '#4e0000',
	'#164100', '#3e0000',
	'#310000'
  ]
  
   */
	sortBySaturation(order: "asc" | "desc", mode?: HueColorSpaces): ColorArray;
	/**
   *
   *  Sorts colors according to their contrast value as defined by WCAG. The contrast is tested against a comparison color (the 'against' param)
   * @param  colors The array of colors to sort
   * @param  order The expected order of arrangement. Either 'asc' or 'desc'. Default is ascending ('asc')
   * @returns An array of the sorted color values.
   * @example
   *
   * import { sortByContrast } from 'huetiful-js'
  
  let sample = ['purple', 'green', 'red', 'brown']
  console.log(sortByContrast(sample, 'yellow'))
  // [ 'red', 'green', 'brown', 'purple' ]
  
  console.log(sortByContrast(sample, 'yellow', 'desc'))
  // [ 'purple', 'brown', 'green', 'red' ]
   
   */
	sortByContrast(against: ColorToken, order?: "asc" | "desc"): ColorArray;
	/**
   *
   *  Sorts colors according to hue values. It works with any color space with a hue channel. Note that hue values between HSL and Lch do not align. Achromatic colors are not supported
   * @param order The expected order of arrangement. Either 'asc' or 'desc'. Default is ascending ('asc')
  * @param colorspace The color space to compute the color distances in. All colors within the collection will be converted to mode. Also note that because differences in hue mapping certain color spaces such as HSL and LCH hue values do not align. Keep such quirks in mind to avoid weird results.
  * @returns  An array of the sorted color values.
   * @example
   * let sample = [
	"#00ffdc",
	"#00ff78",
	"#00c000",
	"#007e00",
	"#164100",
	"#ffff00",
	"#310000",
	"#3e0000",
	"#4e0000",
	"#600000",
	"#720000",
  ];
  
  
  let sorted = sortByHue(sample);
  console.log(sorted)
  // [
	'#310000', '#3e0000',
	'#4e0000', '#600000',
	'#720000', '#ffff00',
	'#164100', '#00c000',
	'#007e00', '#00ff78',
	'#00ffdc'
  ]
  
  let sortedDescending = sortByHue(sample,'desc');
  console.log(sortedDescending)
  // [
	'#00ffdc', '#00ff78',
	'#007e00', '#00c000',
	'#164100', '#ffff00',
	'#720000', '#600000',
	'#4e0000', '#3e0000',
	'#310000'
  ]
  
   */
	sortByHue(order: "asc" | "desc", colorspace: HueColorSpaces): ColorArray;
	/**
	 * @method
	 * @returns Returns the result value from the chain.
	 */
	output(): ColorToken;
}
/**
 * @class
 *  A class that takes an array of colors and exposes all the utilities that handle collections of colors as methods. The methods can be chained as long as `this` being returned can be iterated on. Works like Array object.
 * @param colors An array of colors to chain the array methods on. Every element in the array will be parsed as a color token.
 */
export declare function load(colors: ColorToken[]): ColorArray;
/**
 *
 *  A wrapper function for ColorBrewer's map of sequential color schemes.
 * @param scheme The name of the scheme
 * @returns An array of colors in hex represantation.
 * @example
 * import { sequential } from 'huetiful-js


console.log(sequential("OrRd"))

// [
  '#fff7ec', '#fee8c8',
  '#fdd49e', '#fdbb84',
  '#fc8d59', '#ef6548',
  '#d7301f', '#b30000',
  '#7f0000'
]



 */
export declare function sequential(scheme: SequentialScheme): ColorToken[];
/**
 *
 *  A wrapper function for ColorBrewer's map of diverging color schemes.
 * @param scheme The name of the scheme.
 * @returns An array of colors in hex represantation.
 * @example
 *
 * import { diverging } from 'huetiful-js'



console.log(diverging("Spectral"))
//[
  '#7fc97f', '#beaed4',
  '#fdc086', '#ffff99',
  '#386cb0', '#f0027f',
  '#bf5b17', '#666666'
]
 */
export declare function diverging(scheme: DivergingScheme): ColorToken[];
/**
 *
 *  A wrapper function for ColorBrewer's map of qualitative color schemes.
 * @param scheme The name of the scheme
 * @returns An array of colors in hex represantation.
 * @example
 *
 * import { qualitative } from 'huetiful-js'


console.log(qualitative("Accent"))
// [
  '#7fc97f', '#beaed4',
  '#fdc086', '#ffff99',
  '#386cb0', '#f0027f',
  '#bf5b17', '#666666'
]

 */
export declare function qualitative(scheme: QualitativeScheme): ColorToken[];
/**
 *
 *  A wrapper function for the default Tailwind palette. If called with both parameters it return the hex code at the specified shade and value. Else, if called with the shade parameter as "all" it will return all colors from the shades in the palette map at the specified value (if value is undefined it will default to "500"). When called with the shade parameter only it will return all the colors from 100 to 900 of the specified shade.
 * @param shade Any shade in the default TailwindCSS palette e.g amber,blue.
 * @param value Any value from 100 to 900 in increments of 100 e.g "200".
 * @returns color Returns a hex code string or array of hex codes depending on how the function is called.
 * @example
 *
 * import { colors } from "huetiful-js";

let all300 = colors("all", 300);

console.log(all300)
//[
  '#cbd5e1', '#d1d5db', '#d4d4d8',
  '#d4d4d4', '#d6d3d1', '#fca5a5',
  '#fdba74', '#fcd34d', '#fde047',
  '#bef264', '#86efac', '#6ee7b7',
  '#5eead4', '#7dd3fc', '#93c5fd',
  '#c4b5fd', '#d8b4fe', '#f0abfc',
  '#f9a8d4', '#fda4af'
]

let red = colors("red");
console.log(red);

// [
  '#fef2f2', '#fee2e2',
  '#fecaca', '#fca5a5',
  '#f87171', '#ef4444',
  '#dc2626', '#b91c1c',
  '#991b1b', '#7f1d1d'
]

let red100 = colors("red", 100);

console.log(red100)
// #fee2e2
 */
export declare function colors(shade: TailwindColorFamilies | "all", value?: ScaleValues): ColorToken | ColorToken[];
/**
 *
 *  Wrapper function that returns TailwindCSS color value(s) of the specified shade. If invoked with no parameters it returns an array of colors from 100 to 900. If invoked with parameter will return the specified shade vale,
 * @param  val The tone value of the shade. Values are in incrementals of 100. Both numeric (100) and its string equivalent ('100') are valid.
 * @returns color A hex string value or array of hex strings.
 * @example
 *
 * import { tailwindColors } from "huetiful-js";

// We pass in red as the target hue.
// It returns a function that can be called with an optional value parameter
let red = tailwindColors("red");
console.log(red());
// [
  '#fef2f2', '#fee2e2',
  '#fecaca', '#fca5a5',
  '#f87171', '#ef4444',
  '#dc2626', '#b91c1c',
  '#991b1b', '#7f1d1d'
]


console.log(red(100));
// '#fee2e2'

console.log(red('900'));
// '#7f1d1d'


 *
 */
export declare function tailwindColors(shade: TailwindColorFamilies): (val?: ScaleValues) => string | string[];
export declare class Color {
	constructor(c: ColorToken, options?: ColorOptions);
	alpha(amount?: number | string): Color | number;
	getChannel(channel: string): number;
	setChannel(modeChannel: string, value: number | string): Color;
	via(origin: ColorToken, t?: number, options?: typeof interpolatorConfig): string;
	color2hex(): Color;
	pastel(): Color;
	pairedScheme(options?: PairedSchemeOptions): ColorArray;
	hueShift(options?: HueShiftOptions): ColorArray;
	getComplimentaryHue(mode?: HueColorSpaces, colorObj?: boolean): {
		hue: HueFamily;
		color: ColorToken;
	} | ColorToken;
	contrast(against: "lightMode" | "darkMode" | Color): number;
	luminance(amount?: number): number;
	output(): any;
	saturation(amount?: string | number): any;
	isAchromatic(): boolean;
	isWarm(): boolean;
	isCool(): boolean;
	/**
   *
   *  Returns the color as a simulation of the passed in type of color vision deficiency with the deficiency filter's intensity determined by the severity value.
   * @param deficiencyType The type of color vision deficiency. To avoid writing the long types, the expected parameters are simply the colors that are hard to perceive for the type of color blindness. For example those with 'tritanopia' are unable to perceive 'blue' light. Default is 'red' when the defeciency parameter is undefined or any falsy value.
   * @see For a deep dive on  color vision deficiency go to
   * @param color The color to return its deficiency simulated variant.
   * @param severity The intensity of the filter. The exepected value is between [0,1]. For example 0.5
   * @returns The color as its simulated variant as a hexadecimal string.
   * @example
   *
   * import { colorDeficiency, toHex } from 'huetiful-js'
  
  // Here we are simulating color blindness of tritanomaly or we can't see 'blue'.
  // We are passing in our color as an array of channel values in the mode "rgb". The severity is set to 0.1
  let tritanomaly = colorDeficiency('blue')
  console.log(tritanomaly(['rgb', 230, 100, 50, 0.5], 0.1))
  // #dd663680
  
  // Here we are simulating color blindness of tritanomaly or we can't see 'red'. The severity is not explicitly set so it defaults to 1
  let protanopia = colorDeficiency('red')
  console.log(protanopia({ h: 20, w: 50, b: 30, mode: 'hwb' }))
  // #9f9f9f
   */
	deficiency(deficiencyType?: "red" | "blue" | "green" | "monochromacy", severity?: number): ColorToken;
	getFarthestHue(colors: ColorToken[], colorObj?: boolean): number | {
		factor: number;
		color: ColorToken;
	};
	getNearestHue(colors: ColorToken[], colorObj?: boolean): number | {
		factor: number;
		color: ColorToken;
	};
	getNearestChroma(colors: ColorToken[], colorObj?: boolean): number | {
		factor: number;
		color: ColorToken;
	};
	getNearestLightness(colors: ColorToken[], colorObj?: boolean): number | {
		factor: number;
		color: ColorToken;
	};
	getFarthestChroma(colors: ColorToken[], colorObj?: boolean): number | {
		factor: number;
		color: ColorToken;
	};
	getFarthestLightness(colors: ColorToken[], colorObj?: boolean): number | {
		factor: number;
		color: ColorToken; /**
		 * @method
		 * @returns Returns the result value from the chain.
		 */
	};
	ovetone(): string | boolean;
	getHueFamily(): HueFamily;
	scheme(scheme: "analogous" | "triadic" | "tetradic" | "complementary", easingFunc?: (t: number) => number): ColorToken[] | ColorArray;
}
/**
 * Wrapper function over the Color class that returns a new Color method chain.
 * @param color The color token to bind.
 * @returns A new Color class with all the utilities that take a single color as the first parameter bound to its prototype.
 */
export declare function color(color: ColorToken): Color;
/**
 *
  Gets the hue family which a a color belongs to with the overtone included (if it has one.). For achromatic colors it returns the string "gray".
 * @param color The color to query its shade or hue family.
 * @returns The name of the hue family for example red or green.
 * @example
 *
 * import { getHueFamily } from 'huetiful-js'


console.log(getHueFamily("#310000"))
// red
 */
export declare function getHueFamily(color: ColorToken): HueFamily;
/**
 *
 *  Checks if a color can be roughly classified as a cool color. Returns true if color is a cool color else false.
 * @param color The color to check the temperature.
 * @returns True or false.
 * @example
 *
 * import { isCool } from 'huetiful-js'

let sample = [
  "#00ffdc",
  "#00ff78",
  "#00c000"
];


console.log(isCool(sample[2]));
// false

console.log(map(sample, isCool));

// [ true,  false, true]



 */
export declare function isCool(color: ColorToken): boolean;
/**
 *
 *  Checks if a color can be roughly classified as a warm color. Returns true if color is a warm color else false.
 * @param color The color to check the temperature.
 * @returns True or false.
 * @example import { isWarm } from 'huetiful-js'

let sample = [
  "#00ffdc",
  "#00ff78",
  "#00c000"
];



console.log(isWarm(sample[2]));
//true

console.log(map(sample, isWarm));


// [ false, true,  false]

 */
export declare function isWarm(color: ColorToken): boolean;
/**
 *
 *  Gets the smallest contrast value from the passed in colors compared against a sample color.
 * @param collection The array or object of colors to query the color with the smallest contrast value.
 * @param colorObj Optional boolean that makes the function return a custom object with factor (contrast) and name of the color as keys. Default is false.
 * @param mode THe mode colorspace to retrieve the contrast value from.
 * @returns The smallest contrast value in the colors passed in or a custom object.
 * @example
 *
 * import { getNearestContrast } from 'huetiful-js'
 *
console.log(getNearestContrast(["b2c3f1", "#a1bd2f", "#f3bac1"], "green"));
// 2.4061390502133424

console.log(getNearestContrast(["b2c3f1", "#a1bd2f", "#f3bac1"], "green", true));
// { contrast: 2.4061390502133424, name: '#a1bd2f' }
 */
export declare function getNearestContrast(collection: ColorToken[] | object, against: ColorToken, colorObj?: boolean): any;
/**
 *
 *  Gets the largest contrast value from the passed in colors compared against a sample color.
 * @param collection The array or object of colors to query the color with the largest contrast value.
 * @param colorObj Optional boolean that makes the function return a custom object with factor (contrast) and name of the color as keys. Default is false.
 * @param mode THe mode colorspace to retrieve the contrast value from.
 * @returns The largest contrast value in the colors passed in or a custom object.
 * @example
 *
import { getFarthestContrast } from 'huetiful-js'

console.log(getFarthestContrast(["b2c3f1", "#a1bd2f", "#f3bac1"], "green"));
// 3.08355493246362

console.log(getFarthestContrast(["b2c3f1", "#a1bd2f", "#f3bac1"], "green", true));
// { contrast: 3.08355493246362, name: '#f3bac1' }

 */
export declare function getFarthestContrast(collection: ColorToken[] | object, against: ColorToken, colorObj?: boolean): number | {
	factor: number;
	name: ColorToken;
};
/**
 *
 *  Gets the smallest chroma/saturation value from the passed in colors.
 * @param collection The array or object of colors to query the color with the smallest chroma/saturation value.
 * @param colorspace The mode color space to perform the computation in.
 * @param colorObj Optional boolean that makes the function return a custom object with factor (saturation) and name of the color as keys. Default is false.
 * @returns The smallest chroma/saturation value in the colors passed in or a custom object.
 * @example
 *
 * import { getNearestChroma } from 'huetiful-js'

let sample = ['b2c3f1', '#a1bd2f', '#f3bac1']

console.log(getNearestChroma(sample, 'lch'))
// 22.45669293295522
 */
export declare function getNearestChroma(collection: ColorToken[] | object, colorspace?: HueColorSpaces, colorObj?: boolean): number | {
	factor: number;
	color: ColorToken;
};
/**
 *
 *  Gets the largest saturation value from the passed in colors.
 * @param colors The array or object of colors to query the color with the largest saturation value.
 * @param colorspace The mode color space to perform the computation in.
 * @param colorObj Optional boolean that makes the function return a custom object with factor (saturation) and name of the color as keys. Default is false.
 * @returns The largest saturation value in the colors passed in or a custom object.
 * @example
 *
 * import { getFarthestChroma } from 'huetiful-js'

let sample = ['b2c3f1', '#a1bd2f', '#f3bac1']

console.log(getFarthestChroma(sample, 'lch'))
// 67.22120855010492
 */
export declare function getFarthestChroma(collection: ColorToken[] | object, colorspace?: HueColorSpaces, colorObj?: boolean): number | {
	factor: number;
	color: ColorToken;
};
/**
 *
 *  Gets the smallest hue value from the passed in colors.
 * @param colors The array or object of colors to query the color with the smallest hue value.
 * @param colorspace The mode color space to perform the computation in.
 * @param colorObj Optional boolean that makes the function return a custom object with factor (hue) and name of the color as keys. Default is false.
 * @returns The smallest hue value in the colors passed in or a custom object.
 * @example
 *
 * import { getNearestHue } from 'huetiful-js'

let sample = ['b2c3f1', '#a1bd2f', '#f3bac1']

console.log(getNearestHue(sample, 'lch'))
// 12.462831644544274
 */
export declare function getNearestHue(collection: ColorToken[] | object, colorspace?: HueColorSpaces | string, colorObj?: boolean): number | {
	factor: number;
	color: ColorToken;
};
/**
 *
 *  Gets the largest hue value from the passed in colors.
 * @param colors The array of colors to query the color with the largest hue value.
 * @param colorspace The mode color space to perform the computation in.
 * @param colorObj Optional boolean that makes the function return a custom object with factor (hue) and name of the color as keys. Default is false.
 * @returns The largest hue value in the colors passed in or a custom object.
 * @example
 *
 * import { getFarthestHue } from 'huetiful-js'
let sample = ['b2c3f1', '#a1bd2f', '#f3bac1']

console.log(getFarthestHue(sample, 'lch'))
// 273.54920266436477
 */
export declare function getFarthestHue(collection: ColorToken[] | object, colorspace?: HueColorSpaces, colorObj?: boolean): number | {
	factor: number;
	color: ColorToken;
};
/**
 *
 *  Gets the complementary hue of the passed in color. The function is internally guarded against achromatic colors.
 * @param color The color to retrieve its complimentary hue.
 * @param colorObj Optional boolean whether to return an object with the result color hue family or just the result color. Default is false.
 * @returns An object with the hue family and complimentary color as keys.
 * @example
 *import { getComplimentaryHue } from "huetiful-js";
 *
 *
console.log(getComplimentaryHue("pink",'lch', true))
//// { hue: 'blue-green', color: '#97dfd7ff' }

console.log(getComplimentaryHue("purple"))
// #005700ff
 */
export declare function getComplimentaryHue(color: ColorToken, colorspace?: HueColorSpaces, colorObj?: boolean): {
	hue: string;
	color: ColorToken;
} | ColorToken;
/**
 *
 *  Sets the value for the specified channel in a color.
 * @param  color Any recognizable color token.
 * @param  mc The mode and channel to work with. For example 'rgb.b'.
 * @param  value The value to set on the queried channel. Also supports expressions as strings e.g set('lch.c)("#fc23a1","*0.5")
 * @returns color The mutated color.
 *
 * @example
 *
 * import { setChannel } from 'huetiful-js'

let myColor = setChannel('lch.h')('green',10)

console.log(getChannel('lch.h')(myColor))
// 10
 */
export declare function setChannel(mc: string): (color: ColorToken, value: number | string) => ColorToken;
/**
 *
 *  Gets the  value specifified channel on the color.
 * @param mc The mode and channel to be retrieved. For example "rgb.b" will return the value of the blue channel in the RGB color space of that color.
 * @param color The color being queried.
 * @returns value The value of the queried channel.
 * @example
 *
 * import { getChannel } from 'huetiful-js'

console.log(getChannel('rgb.g')('#a1bd2f'))
// 0.7411764705882353
 * */
export declare function getChannel(mc: string): (color: ColorToken) => number;
/** @alias
 * Gets the luminance value of that color as defined by WCAG.
 * @param color The color to query.
 * @returns value The color's luminance value.
 * @example
 *
 * import { getLuminance,colors } from 'huetiful-js'

console.log(getLuminance('#a1bd2f'))
// 0.4417749513730954

console.log(colors('all', '400').map(getLuminance));

// [
   0.3595097699638928,  0.3635745068550118,
   0.3596908494424909,  0.3662525955988395,
  0.36634113914916244, 0.32958967582076004,
  0.41393242740130043,  0.5789820793721787,
   0.6356386777636567,  0.6463720036841869,
   0.5525691083297639,  0.4961850321908156,
   0.5140644334784611,  0.4401325598899415,
  0.36299191043315415,  0.3358285501372504,
  0.34737270839643575, 0.37670102542883394,
   0.3464512307705231, 0.34012939384198054
]
 */
export declare function getLuminance(color: ColorToken): number;
/**
 *
 *  Sets the luminance by interpolating the color with black (to decrease luminance) or white (to increase the luminance).
 * @param color The color to set luminance
 * @param lum The amount of luminance to set. The value range is normalised between [0,1]
 * @returns The mutated color with the modified properties.
 * @example
 *
 * import { setLuminance, getLuminance } from 'huetiful-js'

let myColor = setLuminance('#a1bd2f', 0.5)

console.log(getLuminance(myColor))
// 0.4999999136285792
 */
export declare function setLuminance(color: ColorToken, lum: number): ColorToken;
/**
 *
 *  Sets the opacity of a color. Also gets the alpha value of the color if the value param is omitted
 * @param color The color with the targeted opacity/alpha channel.
 * @param value The value to apply to the opacity channel. The value is between [0,1]
 * @returns color The resulting color. Returns an 8 character hex code.
 * @example
 *
 * // Getting the alpha
console.log(alpha('#a1bd2f0d'))
// 0.050980392156862744

// Setting the alpha

let myColor = alpha('b2c3f1', 0.5)

console.log(myColor)

// #b2c3f180
 */
export declare function alpha(color: ColorToken, value?: number | string): number;
/**
 *
 *  Gets the contrast between the passed in colors.
 * @param color
 * @param against
 * @returns The relative luminance of the lightest color.
 * @example
 *
 * import { getContrast } from 'huetiful-js'
 *
 * console.log(getContrast("black", "white"));
 * // 21
 */
export declare function getContrast(color: ColorToken, against: ColorToken): number;
/**
 *
 *  Returns the hue which is biasing the passed in color
 * @param color The color to query its overtone.
 * @returns The name of the overtone hue. If an achromatic color is passed in it return the string gray otherwise if the color has no bias it returns false.
 * @example
 *
 * import { overtone } from "huetiful-js";
 *
console.log(overtone("fefefe"))
// 'gray'

console.log(overtone("cyan"))
// 'green'

console.log(overtone("blue"))
// false
 */
export declare function overtone(color: ColorToken): string | boolean;
/**
 *
 *  Gets the smallest lightness value from the passed in colors.
 * @param collection The array or object of colors to query the color with the smallest lightness value.
 * @param colorObj Optional boolean that makes the function return a custom object with factor (lightness) and name of the color as keys. Default is false.
 * @param mode THe mode colorspace to retrieve the lightness value from.
 * @returns The smallest lightness value in the colors passed in or a custom object.
 * @example
 *
 * import { getNearestLightness } from 'huetiful-js'

let sample = ["b2c3f1", "#a1bd2f", "#f3bac1"]

console.log(getNearestLightness(sample, 'lch',true))

// { lightness: 72.61647882089876, name: '#a1bd2f' }

 */
export declare function getNearestLightness(collection: ColorToken[] | object, colorspace?: HueColorSpaces, colorObj?: boolean): number | {
	factor: number;
	color: ColorToken;
};
/**
 *
 *  Gets the largest lightness value from the passed in colors.
 * @param collection The array or object of colors to query the color with the largest lightness value.
 * @param colorObj Optional boolean that makes the function return a custom object with factor (lightness) and name of the color as keys. Default is false.
 * @param colorspace THe mode colorspace to retrieve the lightness value from.
 * @returns The largest lightness value in the colors passed in or a custom object.
 * @example
 *
 * import { getFarthestLightness } from 'huetiful-js'

let sample = ["b2c3f1", "#a1bd2f", "#f3bac1"]

console.log(getFarthestLightness(sample, 'lch',true))

// { lightness: 80.94668903360088, name: '#f3bac1' }

 */
export declare function getFarthestLightness(collection: ColorToken[] | object, colorspace?: HueColorSpaces, colorObj?: boolean): number | {
	factor: number;
	color: ColorToken;
};
/**
 *
 *  Darkens the color by reducing the lightness channel. .
 * @param   color The color to darken.
 * @param value The amount to darken with. Also supports expressions as strings e.g darken("#fc23a1","*0.5")
 * @returns color The darkened color.
 * @example
 *
 *

 */
/**
 *
 * @param color The color to brighten.
 * @param value The amount to brighten with. Also supports expressions as strings e.g darken("#fc23a1","*0.5")
 * @param mode The color space to compute the color in. Any color space with a lightness channel will do (including HWB)
 * @returns
 */
/**
 *
 *  Checks if a color is achromatic(without hue or simply grayscale).
 * @param color The color to test if it is achromatic or not.
 * @returns boolean Returns true if the color is achromatic else false
 * @example
 *
 * import { isAchromatic } from "huetiful-js";
import { formatHex8, interpolate, samples } from "culori"


isAchromatic('pink')
// false

let sample = [
  "#164100",
  "#ffff00",
  "#310000",
  'pink'
];

console.log(map(sample, isAchromatic));

// [false, false, false,false]

isAchromatic('gray')
// Returns true


console.log(map(sample, isAchromatic));


// we create an interpolation using black and white
let f = interpolate(["black", "white"]);

//We then create 12 evenly spaced samples and pass them to f as the `t` param required by an interpolating function.
// Lastly we convert the color to hex for brevity for this example (otherwise color objects work fine too.)
let grays = map(samples(12), (c) => formatHex8(f(c)));
console.log(map(grays, isAchromatic));

//
 [ false, true, true,
  true,  true, true,
  true,  true, true,
  true,  true, false
]

 */
export declare function isAchromatic(color: ColorToken, mode?: HueColorSpaces): boolean;
/**
 *
 *  Returns the color as a simulation of the passed in type of color vision deficiency with the deficiency filter's intensity determined by the severity value.
 * @param deficiencyType The type of color vision deficiency. To avoid writing the long types, the expected parameters are simply the colors that are hard to perceive for the type of color blindness. For example those with 'tritanopia' are unable to perceive 'blue' light. Default is 'red' when the defeciency parameter is undefined or any falsy value.
 * @param color The color to return its deficiency simulated variant.
 * @param severity The intensity of the filter. The exepected value is between [0,1]. For example 0.5
 * @returns The color as its simulated variant as a hexadecimal string.
 * @example
 *
 * import { colorDeficiency, color2hex } from 'huetiful-js'

// Here we are simulating color blindness of tritanomaly or we can't see 'blue'.
// We are passing in our color as an array of channel values in the mode "rgb". The severity is set to 0.1
let tritanomaly = colorDeficiency('blue')
console.log(tritanomaly(['rgb', 230, 100, 50, 0.5], 0.1))
// #dd663680

// Here we are simulating color blindness of tritanomaly or we can't see 'red'. The severity is not explicitly set so it defaults to 1
let protanopia = colorDeficiency('red')
console.log(protanopia({ h: 20, w: 50, b: 30, mode: 'hwb' }))
// #9f9f9f
 */
export declare function colorDeficiency(deficiencyType?: DeficiencyType): (color: ColorToken, severity?: number) => string;
/**
 *
 * @param collection The collection of colors to search for nearest colors
 * @param color The color to use for distance comparison
 * @param num The number of colors to return, if the value is above the colors in the available sample, the entire collection is returned with colors ordered in ascending order using the differenceHyab metric.
 * @returns An array of colors.
 * @example
 *
 * let cols = colors('all', '500')
 *
console.log(getNearestColor(cols, 'blue', 3));
 // [ '#a855f7', '#8b5cf6', '#d946ef' ]
 */
export declare function getNearestColor(collection: ColorToken[] | "tailwind", color: ColorToken, num?: number): ColorToken | ColorToken[];
/**
 *
 *  Generates a randomised classic color scheme from a single scheme color.
 * @param  schemeType  Any classic color scheme either "analogous"|"triadic"|"tetradic"|"complementary"|"splitComplementary".
 * @returns An array of 8 character hex codes. Elements in the array depend on the number of sample colors in the targeted scheme.
 * @example
 *
 import { scheme } from 'huetiful-js'

console.log(scheme("triadic")("#a1bd2f", true))
// [ '#a1bd2fff', '#00caffff', '#ff78c9ff' ]
 */
export declare function scheme(schemeType: "analogous" | "triadic" | "tetradic" | "complementary" | string): (color: ColorToken, easingFunc?: (t: number) => number) => ColorToken[];
/**
 *
 *  Takes an array of colors and finds the best matches for a set of predefined palettes. The function does not work on achromatic colors, you may use isAchromatic to filter grays from your collection before passing it to the function.
 * @param colors The array of colors to create palettes from. Preferably use 5 or more colors for better results.
 * @param schemeType (Optional) The palette type you want to return.
 * @returns An array of colors if the scheme parameter is specified else it returns an object of all the palette types as keys and their values as an array of colors. If no colors are valid for the palette types it returns an empty array for the palette results.
 * @example
 *
 * import { discoverPalettes } from 'huetiful-js'

let sample = [
  "#ffff00",
  "#00ffdc",
  "#00ff78",
  "#00c000",
  "#007e00",
  "#164100",
  "#720000",
  "#600000",
  "#4e0000",
  "#3e0000",
  "#310000",
]

console.log(discoverPalettes(sample, "tetradic"))
// [ '#ffff00ff', '#00ffdcff', '#310000ff', '#720000ff' ]
 */
export declare function discoverPalettes(colors: ColorToken[], schemeType?: "analogous" | "triadic" | "tetradic" | "complementary", colorspace?: UniformColorSpaces): ColorToken[] | object;
/**
 *
 *  Creates a scale of a spline interpolation between an earthtone and a color.
 * @param color The color to interpolate an earth tone with.
  * @param options Optional overrides for customising interpolation and easing functions.
 * @returns The array of colors resulting from the earthtone interpolation as hex codes.
 * @example
 *
 * import { earthtone } from 'huetiful-js'


console.log(earthtone("pink",'lch',{earthtones:'clay',samples:5 }))
// [ '#6a5c52ff', '#8d746aff', '#b38d86ff', '#d9a6a6ff', '#ffc0cbff' ]

 */
/**
 *
 *  Generates a palette of hue shifted colors (as a color becomes lighter, its hue shifts up and darker when its hue shifts  down) from a single scheme color. Min and max lightness value determine how light or dark our colour will be at either extreme.
 * @param color The color to use as the scheme of the hueshift. Colors are internally converted to LCH.
 * @param options The optional overrides object to customize per channel options like interpolation methods and channel fixups.
 *@returns An array of colors in hex. The length of the resultant array is the number of iterations multiplied by 2 plus the scheme color passed or (iterations*2)+1
 * @example
 * import { hueShift } from "huetiful-js";

let hueShiftedPalette = hueShift("#3e0000");

console.log(hueShiftedPalette);

// [
  '#ffffe1', '#ffdca5',
  '#ca9a70', '#935c40',
  '#5c2418', '#3e0000',
  '#310000', '#34000f',
  '#38001e', '#3b002c',
  '#3b0c3a'
]
 */
export declare function hueShift(color: ColorToken, colorspace?: UniformColorSpaces, options?: HueShiftOptions): ColorToken[];
/**
 *
 *  Returns a spline interpolator function with customizable interpolation methods (passed in as 'kind') and optional channel specific overrides.
 * @param colors The array of colors to interpolate. If a color has a falsy channel for example black has an undefined hue channel some interpolation methods may return NaN affecting the final result.
 * @param colorspace The colorspace to perform the color space in. Prefer uniform color spaces for better results such as Lch or Jch.
 * @param kind The type of the spline interpolation method. Default is basis.
 * @param closed Optional parameter to return the 'closed' variant of the 'kind' of interpolation method which can be useful for cyclical color scales. Default is false
 * @param options Optional channel specific overrides.
 * @returns A hexadecimal representation of the resultant color.
 *
 * @example
 *
 */
export declare function interpolateSpline(colors: ColorToken[], colorspace?: HueColorSpaces, samples?: number, kind?: "natural" | "monotone" | "basis", closed?: boolean, options?: InterpolatorOptions): ColorToken[];
/**
 * @internal
 */
export declare function interpolator(colors: ColorToken[], colorspace?: HueColorSpaces, options?: object): (t: number) => import("culori/src/common").FindColorByMode<"lch" | "jch" | "dlch" | "lch65" | "lchuv" | "oklch" | "hsl" | "hsv" | "hsi" | "hwb" | "okhsl" | "okhsv" | "rgb" | "a98" | "cubehelix" | "dlab" | "jab" | "lab" | "lab65" | "lrgb" | "luv" | "oklab" | "p3" | "prophoto" | "rec2020" | "xyz50" | "xyz65" | "yiq">;
/**
 *  Creates a scheme that consists of a scheme color that is incremented by a hueStep to get the final hue to pair with.The colors are interpolated via white or black.
 * @param color The color to return a paired color scheme from.
 * @param options The optional overrides object to customize per channel options like interpolation methods and channel fixups.
 * @returns An array containing the paired scheme.
 * @example
 *
 * import { pairedScheme } from 'huetiful-js'

console.log(pairedScheme("green",{hueStep:6,samples:4,tone:'dark'}))
// [ '#008116ff', '#006945ff', '#184b4eff', '#007606ff' ]
 */
export declare function pairedScheme(color: ColorToken, options?: PairedSchemeOptions): ColorToken[] | ColorToken;
/**
 *
 *  Returns a random pastel variant of the passed in color.
 * @param color The color to return a pastel variant of.
 * @returns A random pastel color.
 * @example
 *
 *
import { pastel } from 'huetiful-js'

console.log(pastel("green"))
// #036103ff
 */
export declare function pastel(color: ColorToken): ColorToken;
/**
 *
 * Returns an array of colors in the specified saturation range.
 *
 * The range is internally normalized to the supported ranges by the `colorspace` in use if it is out of range.
 * This means a value in the range `[0,1]` will return, for example if you pass startSaturation as `0.3` it means `0.3 (or 30%)` of the channel's supported range. But if the value of either start or end is above 1 AND the `colorspace` in use has an end range higher than 1 then the value is treated as if in the unnormalized range else the value is treated as if in the range `[0,100]` and will return the normalized value.
 * @param  collection The collection of colors to filter.
 * @param  startSaturation The minimum end of the saturation range. Supports expression strings e.g `'>=0.5'`. The supported symbols are `== | === | != | !== | >= | <= | < | >`
 * @param  endSaturation The maximum end of the saturation range.
 * @param colorspace The color space to fetch the saturation value from. Any color space with a chroma channel e.g 'lch' or 'hsl' will do.
 * @returns Collection of filtered colors.
 * @example
 * import { filterBySaturation } from 'huetiful-js'


let sample = [
  '#00ffdc',
  '#00ff78',
  '#00c000',
  '#007e00',
  '#164100',
  '#ffff00',
  '#310000',
  '#3e0000',
  '#4e0000',
  '#600000',
  '#720000'
];

console.log(filterBySaturation(sample, 0.1));

// [ '#00ff78', '#00c000', '#007e00', '#ffff00' ]
 */
export declare function filterBySaturation(collection: ColorToken[] | object, startSaturation?: number, endSaturation?: number, colorspace?: HueColorSpaces): ColorToken[];
/**
 *
 *  Returns an array of colors in the specified luminance range.
 * @param  collection The collection of colors to filter.
 * @param  startLuminance The minimum end of the luminance range.Supports expression strings e.g `'>=0.5'`. The supported symbols are `== | === | != | !== | >= | <= | < | >`
 * @param  endLuminance The maximum end of the luminance range.
 * @returns Collection of filtered colors.
 * @example
 *
 * import { filterByLuminance } from 'huetiful-js'
let sample = [
  '#00ffdc',
  '#00ff78',
  '#00c000',
  '#007e00',
  '#164100',
  '#ffff00',
  '#310000',
  '#3e0000',
  '#4e0000',
  '#600000',
  '#720000',
]

filterByLuminance(sample, 0.4, 0.9)

// [ '#00ffdc', '#00ff78' ]
 */
export declare function filterByLuminance(collection: ColorToken[] | object, startLuminance?: number, endLuminance?: number): ColorToken[];
/**
 *
 *  Returns an array of colors in the specified lightness range.
 *
 * The range is internally normalized to the supported ranges by the `colorspace` in use if it is out of range.
 * This means a value in the range `[0,1]` will return, for example if you pass `startLightness` as `0.3` it means `0.3 (or 30%)` of the channel's supported range. But if the value of either start or end is above 1 AND the `colorspace` in use has an end range higher than 1 then the value is treated as is else the value is treated as if in the range `[0,100]` and will return the normalized value.
 * @param  collection The collection of colors to filter.
 * @param  startLightness The minimum end of the lightness range. Supports expression strings e.g `'>=0.5'`. The supported symbols are `== | === | != | !== | >= | <= | < | >`
 * @param  endLightness The maximum end of the lightness range.
 * @param colorspace The mode colorspace to retrieve the lightness value from. The default is lch65
 * @returns Collection of filtered colors.
 * @example
 *
 * import { filterByLightness } from 'huetiful-js'
let sample = [
  '#00ffdc',
  '#00ff78',
  '#00c000',
  '#007e00',
  '#164100',
  '#ffff00',
  '#310000',
  '#3e0000',
  '#4e0000',
  '#600000',
  '#720000',
]

filterByLightness(sample, 20, 80)

// [ '#00c000', '#007e00', '#164100', '#720000' ]
 */
export declare function filterByLightness(collection: ColorToken[] | object, startLightness?: number, endLightness?: number, colorspace?: HueColorSpaces): ColorToken[];
/**
 *
 * Returns colors in the specified hue ranges between 0 to 360.
 * @param collection The collection of colors to filter.
 * @param  startHue The minimum end of the hue range. Supports expression strings e.g `'>=0.5'`. The supported symbols are `== | === | != | !== | >= | <= | < | >`
 * @param  endHue The maximum end of the hue range.
 * @returns  Array of the filtered colors.
 * @example
 * let sample = [
  '#00ffdc',
  '#00ff78',
  '#00c000',
  '#007e00',
  '#164100',
  '#ffff00',
  '#310000',
  '#3e0000',
  '#4e0000',
  '#600000',
  '#720000',
]

filterByHue(sample, 20, 80)

// [ '#310000', '#3e0000', '#4e0000', '#600000', '#720000' ]
 */
export declare function filterByHue(collection: ColorToken[] | object, startHue?: number, endHue?: number, colorspace?: HueColorSpaces): ColorToken[];
/**
 *
 * Returns an array of colors with the specified distance range. The distance is tested against a comparison color (the 'against' param) and the specified distance ranges. Uses the differenceHyab metric for calculating the distances.
 * @param  collection The collection of colors to filter.
 * @param  startDistance The minimum end of the distance range.Supports expression strings e.g `'>=0.5'`. The supported symbols are `== | === | != | !== | >= | <= | < | >`
 * @param  endDistance The maximum end of the distance range.
 * @returns Collection of filtered colors.
 * @example
 * import { filterByDistance } from 'huetiful-js'

let sample = [
  "#ffff00",
  "#00ffdc",
  "#00ff78",
  "#00c000",
  "#007e00",
  "#164100",
  "#720000",
  "#600000",
]

console.log(filterByDistance(sample, "yellow", 0.1))
// [ '#ffff00' ]
 */
export declare function filterByDistance(collection: ColorToken[] | object, against: ColorToken, startDistance?: number, endDistance?: number): ColorToken[];
/**
 *
 * Returns an array of colors with the specified contrast range. The contrast is tested against a comparison color (the 'against' param) and the specified contrast ranges.
 * @param  collection The collection of colors to filter.
 * @param  startContrast The minimum end of the contrast range.Supports expression strings e.g `'>=0.5'`. The supported symbols are `== | === | != | !== | >= | <= | < | >`
 * @param  endContrast The maximum end of the contrast range.
 * @returns Collection of filtered colors.
 *
 * @example
 *
 * import { filterByContrast } from 'huetiful-js'

let sample = [
  '#00ffdc',
  '#00ff78',
  '#00c000',
  '#007e00',
  '#164100',
  '#ffff00',
  '#310000',
  '#3e0000',
  '#4e0000',
  '#600000',
  '#720000',
]

console.log(filterByContrast(sample, 'green', '>=3'))
// [ '#00ffdc', '#00ff78', '#ffff00', '#310000', '#3e0000', '#4e0000' ]
 */
export declare function filterByContrast(collection: ColorToken[] | object, against: ColorToken, startContrast?: number, endContrast?: number): ColorToken[];
/**
 *
 * Sorts colors according to their saturation.
 * @param  colors The array of colors to sort
 * @param  order The expected order of arrangement. Either 'asc' or 'desc'. Default is ascending ('asc')
 * @param mode The mode color space to compute the saturation value in. The default is jch .
 * @returns An array of the sorted color values.
 * @example
 * import { sortBySaturation } from "huetiful-js";
let sample = [
  "#00ffdc",
  "#00ff78",
  "#00c000",
  "#007e00",
  "#164100",
  "#ffff00",
  "#310000",
  "#3e0000",
  "#4e0000",
  "#600000",
  "#720000",
];

let sorted = sortBySaturation(sample);
console.log(sorted);

// [
  '#310000', '#3e0000',
  '#164100', '#4e0000',
  '#600000', '#720000',
  '#00ffdc', '#007e00',
  '#00ff78', '#00c000',
  '#ffff00'
]

let sortedDescending = sortBySaturation(sample,'desc');
console.log(sortedDescending)
// [
  '#ffff00', '#00c000',
  '#00ff78', '#007e00',
  '#00ffdc', '#720000',
  '#600000', '#4e0000',
  '#164100', '#3e0000',
  '#310000'
]

 */
export declare function sortBySaturation(collection: ColorToken[] | object, order: "asc" | "desc", mode?: HueColorSpaces): ColorToken[];
/**
 *
 *  Sorts colors according to the relative brightness as defined by WCAG definition.
 * @param  colors The array of colors to sort
 * @param  order The expected order of arrangement. Either 'asc' or 'desc'. Default is ascending ('asc')
 * @returns An array of the sorted color values.
 * @example
 * import { sortByLuminance } from "huetiful-js";
let sample = [
  "#00ffdc",
  "#00ff78",
  "#00c000",
  "#007e00",
  "#164100",
  "#ffff00",
  "#310000",
  "#3e0000",
  "#4e0000",
  "#600000",
  "#720000",
];



let sorted = sortByLuminance(sample)
console.log(sorted)
// [
  '#310000', '#3e0000',
  '#4e0000', '#600000',
  '#720000', '#164100',
  '#007e00', '#00c000',
  '#00ff78', '#00ffdc',
  '#ffff00'
]

let sortedDescending = sortByLuminance(sample, "desc");
console.log(sortedDescending)
// [
  '#ffff00', '#00ffdc',
  '#00ff78', '#00c000',
  '#007e00', '#164100',
  '#720000', '#600000',
  '#4e0000', '#3e0000',
  '#310000'
]

 
 */
export declare function sortByLuminance(collection: ColorToken[] | object, order: "asc" | "desc"): ColorToken[];
/**
 *
 *  Sorts colors according to their lightness.
 * @param  colors The array of colors to sort
 * @param  order The expected order of arrangement. Either 'asc' or 'desc'. Default is ascending ('asc')
 * @param colorspace The mode colorspace to use for filtering color lightness. Defaut is lch65
 * @returns An array of the sorted color values.
 * @example
 * import { sortByLightness } from "huetiful-js";

let sample = [
  "#00ffdc",
  "#00ff78",
  "#00c000",
  "#007e00",
  "#164100",
  "#ffff00",
  "#310000",
  "#3e0000",
  "#4e0000",
  "#600000",
  "#720000",
]

sortByLightness(sample)

// [
  '#310000', '#3e0000',
  '#4e0000', '#600000',
  '#720000', '#164100',
  '#007e00', '#00c000',
  '#00ff78', '#00ffdc',
  '#ffff00'
]


sortByLightness(sample,'desc')

// [
  '#ffff00', '#00ffdc',
  '#00ff78', '#00c000',
  '#007e00', '#164100',
  '#720000', '#600000',
  '#4e0000', '#3e0000',
  '#310000'
]

 */
export declare function sortByLightness(collection: ColorToken[] | object, order?: Order, colorspace?: HueColorSpaces): ColorToken[];
/**
 *
 *  Sorts colors according to hue values. It works with any color space with a hue channel. Note that hue values between HSL and Lch do not align. Achromatic colors are not supported
 * @param  colors The array of colors to sort
 * @param order The expected order of arrangement. Either 'asc' or 'desc'. Default is ascending ('asc')
* @param colorspace The color space to compute the color distances in. All colors within the collection will be converted to mode. Also note that because differences in hue mapping certain color spaces such as HSL and LCH hue values do not align. Keep such quirks in mind to avoid weird results.
* @returns  An array of the sorted color values.
 * @example
 * let sample = [
  "#00ffdc",
  "#00ff78",
  "#00c000",
  "#007e00",
  "#164100",
  "#ffff00",
  "#310000",
  "#3e0000",
  "#4e0000",
  "#600000",
  "#720000",
];


let sorted = sortByHue(sample);
console.log(sorted)
// [
  '#310000', '#3e0000',
  '#4e0000', '#600000',
  '#720000', '#ffff00',
  '#164100', '#00c000',
  '#007e00', '#00ff78',
  '#00ffdc'
]

let sortedDescending = sortByHue(sample,'desc');
console.log(sortedDescending)
// [
  '#00ffdc', '#00ff78',
  '#007e00', '#00c000',
  '#164100', '#ffff00',
  '#720000', '#600000',
  '#4e0000', '#3e0000',
  '#310000'
]

 */
export declare function sortByHue(collection: ColorToken[] | object, order?: Order, colorspace?: HueColorSpaces): ColorToken[];
/**
 *
 *  Sorts colors according to their contrast value as defined by WCAG. The contrast is tested against a comparison color (the 'against' param)
 * @param  colors The array of colors to sort
 * @param  order The expected order of arrangement. Either 'asc' or 'desc'. Default is ascending ('asc')
 * @returns An array of the sorted color values.
 * @example
 *
 * import { sortByContrast } from 'huetiful-js'

let sample = ['purple', 'green', 'red', 'brown']
console.log(sortByContrast(sample, 'yellow'))
// [ 'red', 'green', 'brown', 'purple' ]

console.log(sortByContrast(sample, 'yellow', 'desc'))
// [ 'purple', 'brown', 'green', 'red' ]
 
 */
export declare function sortByContrast(collection: ColorToken[] | object, against: ColorToken, order?: Order): ColorToken[];
/**
 *
 *  Sorts colors according to their Euclidean distance. The distance factor is determined by the color space used (some color spaces are not symmetrical meaning that the distance between colorA and colorB is not equal to the distance between colorB and colorA ). The distance is computed from against a color which is used for comparison for all the colors in the array i.e it sorts the colors against the dist
 * @param  colors The array of colors to sort.
 * @param against The color to compare the distance with. All the distances are calculated between this color and the ones in the colors array.
 * @param  order The expected order of arrangement. Either 'asc' or 'desc'. Default is ascending ('asc')
 * @param weights The weighting values to pass to the Euclidean function. Default is [1,1,1,0].
 * @param mode The color space to calculate the distance in . The default is the cylindrical variant of the CIELUV colorspace ('lchuv')
 * @returns An array of the sorted color values.
 * @example
 * import { sortByDistance } from 'huetiful-js'

let sample = ['purple', 'green', 'red', 'brown']
console.log(
  sortByDistance(sample, 'yellow', 'asc', {
	mode: 'lch',
  })
)

// [ 'brown', 'red', 'green', 'purple' ]

let sample = ['purple', 'green', 'red', 'brown']
console.log(
  sortByDistance(sample, 'yellow', 'asc', {
	mode: 'lch',
  })
)

// [ 'green', 'brown', 'red', 'purple' ]
 */
export declare function sortByDistance(collection: ColorToken[] | object, against: ColorToken, order?: "asc" | "desc", options?: ColorDistanceOptions): ColorToken[];
/**
 * Converter function with mode definitions for uniform color spaces. The function is curried to return a converter in the passed colospace.
 * @param colorspace The mode converter to return.
 * @returns The converter function in the mode colorspace.
 */
export declare function ucsConverter(colorspace: UniformColorSpaces): import("culori/src/converter").ConvertFn<any>;
/**
 *
  Converts a wide range of color tokens which are color objects, and CSS named colors  (for example 'red'), numbers from 0 to 166,777,215 and arrays in the form of [string,number,number,number,numer?] the first element in the array being the mode color space and the fourth optional number element as the opacity value to hexadecimal.
 * @param color The color to convert to hexadecimal. Works on color objects and CSS named colors.
 * @returns A hexadecimal representation of the passed in color.
 * @example
 * import { color2hex } from "huetiful-js";
 *
console.log(color2hex({ l: 50, c: 31, h: 100, alpha: 0.5, mode: "lch" }))
// #7b794180

console.log(color2hex({ l: 50, c: 31, h: 100, mode: "lch" }))
// #7b7941
 */
export declare function color2hex(color: ColorToken): string;
/**
 *
 *  Returns the color equivalent of any number between 0 and 16,777,215 as a hexadecimal string or color object if the `colorspace` is specified.
 * @param num The number to convert.
 * @returns color A color object or hex string.
 * @example
 *
 * import { num2color } from 'huetiful-js'

console.log(num2color(900))
// #000384
 */
export declare function num2color(num: number, colorspace?: Colorspaces): ColorToken;
/**
 *
 *  Returns the numerical equivalent of a color.
 * @param color The color to convert to its numerical equivalent.
 * @returns value The numerical value of the color from 0 to 16,777,215.
 * @example
 *
 * import { color2num } from 'huetiful-js'

console.log(color2num("b2c3f1"))
// 11715569
 */
export declare function color2num(color: ColorToken): number;
/**
 *
 *  Converts the temperature value (in Kelvins) to a color as a hexadecimal string else a color object in the mode `colorspace`.
 * @param kelvin The number of Kelvins. From 0 to 30,000 .
 * @param colorspace Optional parameter to return a color object in the mode `colorspace` hexadecimal string. Default is `'rgb'`
 * @returns color The color as a hexadecimal  or RGB color object.
 * @example
 *
 * import { temp2color } from 'huetiful-js'

console.log(temp2color(2542))
// #ffa44a
 */
export declare function temp2color(kelvin: number, colorspace?: Colorspaces): ColorToken;
/**
 *
 *  Returns an array of channel values in the mode color space. It does not mutate the values of the passed in color token.
 * @param color Expects the color to be in hexadecimal represantation or as a plain color object. Use a converter suitable for the color token type you're expecting to convert it to hexadecimal format e.g `num2color`.
 * @param colorspace The mode color space to return channel values for. You can omit this parameter if you pass in a color object with the `mode` property.
 * @returns An array of channel values with the colorspace as first element and the alpha channel if its explicitly defined in the passed in color.
 * @example
 *
 *
let rgbColor = {
  r: 0.4,
  g: 0.3,
  b: 0.7,
  mode: "rgb",
};
console.log(color2tuple(rgbColor));

// [ 'rgb', 0.4, 0.3, 0.7 ]

 */
export declare function color2tuple(color: string | object, colorspace?: Colorspaces): any[];

export {};
