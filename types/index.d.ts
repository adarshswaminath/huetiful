// Generated by dts-bundle-generator v8.0.1

import { Color as _color } from 'culori';

export type palette = "analogous" | "triadic" | "tetradic" | " complementary" | "splitComplementary";
export type Color = number | string | object | keyof _color;
/**
 * @param
 * An array of baseColor tokens (in short, just an array of valid colors)
 */
/**
 * @param
 *
 */
export type filterBy = (colors: Color[], start: number, end: number) => Color[];
export type sortBy = (colors: Color[], order: "asc" | "desc") => Color[];
export type ScaleValues = {
	"100": string;
	"50": string;
	"200": string;
	"300": string;
	"400": string;
	"500": string;
	"600": string;
	"700": string;
	"800": string;
	"900": string;
};
// The users dont interact directly with the Color instance rather it is wrapped in a function and acts as an entry wrapper to the underlying class meta.
export type HueMap = {
	indigo: {
		"50": string;
		"100": string;
		"200": string;
		"300": string;
		"400": string;
		"500": string;
		"600": string;
		"700": string;
		"800": string;
		"900": string;
	};
	gray: {
		"50": string;
		"100": string;
		"200": string;
		"300": string;
		"400": string;
		"500": string;
		"600": string;
		"700": string;
		"800": string;
		"900": string;
	};
	zinc: {
		"50": string;
		"100": string;
		"200": string;
		"300": string;
		"400": string;
		"500": string;
		"600": string;
		"700": string;
		"800": string;
		"900": string;
	};
	neutral: {
		"50": string;
		"100": string;
		"200": string;
		"300": string;
		"400": string;
		"500": string;
		"600": string;
		"700": string;
		"800": string;
		"900": string;
	};
	stone: {
		"50": string;
		"100": string;
		"200": string;
		"300": string;
		"400": string;
		"500": string;
		"600": string;
		"700": string;
		"800": string;
		"900": string;
	};
	red: {
		"50": string;
		"100": string;
		"200": string;
		"300": string;
		"400": string;
		"500": string;
		"600": string;
		"700": string;
		"800": string;
		"900": string;
	};
	orange: {
		"50": string;
		"100": string;
		"200": string;
		"300": string;
		"400": string;
		"500": string;
		"600": string;
		"700": string;
		"800": string;
		"900": string;
	};
	amber: {
		"50": string;
		"100": string;
		"200": string;
		"300": string;
		"400": string;
		"500": string;
		"600": string;
		"700": string;
		"800": string;
		"900": string;
	};
	yellow: {
		"50": string;
		"100": string;
		"200": string;
		"300": string;
		"400": string;
		"500": string;
		"600": string;
		"700": string;
		"800": string;
		"900": string;
	};
	lime: {
		"50": string;
		"100": string;
		"200": string;
		"300": string;
		"400": string;
		"500": string;
		"600": string;
		"700": string;
		"800": string;
		"900": string;
	};
	green: {
		"50": string;
		"100": string;
		"200": string;
		"300": string;
		"400": string;
		"500": string;
		"600": string;
		"700": string;
		"800": string;
		"900": string;
	};
	emerald: {
		"50": string;
		"100": string;
		"200": string;
		"300": string;
		"400": string;
		"500": string;
		"600": string;
		"700": string;
		"800": string;
		"900": string;
	};
	teal: {
		"50": string;
		"100": string;
		"200": string;
		"300": string;
		"400": string;
		"500": string;
		"600": string;
		"700": string;
		"800": string;
		"900": string;
	};
	sky: {
		"50": string;
		"100": string;
		"200": string;
		"300": string;
		"400": string;
		"500": string;
		"600": string;
		"700": string;
		"800": string;
		"900": string;
	};
	blue: {
		"50": string;
		"100": string;
		"200": string;
		"300": string;
		"400": string;
		"500": string;
		"600": string;
		"700": string;
		"800": string;
		"900": string;
	};
	violet: {
		"50": string;
		"100": string;
		"200": string;
		"300": string;
		"400": string;
		"500": string;
		"600": string;
		"700": string;
		"800": string;
		"900": string;
	};
	purple: {
		"50": string;
		"100": string;
		"200": string;
		"300": string;
		"400": string;
		"500": string;
		"600": string;
		"700": string;
		"800": string;
		"900": string;
	};
	fuchsia: {
		"50": string;
		"100": string;
		"200": string;
		"300": string;
		"400": string;
		"500": string;
		"600": string;
		"700": string;
		"800": string;
		"900": string;
	};
	pink: {
		"50": string;
		"100": string;
		"200": string;
		"300": string;
		"400": string;
		"500": string;
		"600": string;
		"700": string;
		"800": string;
		"900": string;
	};
	rose: {
		"50": string;
		"100": string;
		"200": string;
		"300": string;
		"400": string;
		"500": string;
		"600": string;
		"700": string;
		"800": string;
		"900": string;
	};
};
/**
 * @function
 * @description Sets the opacity of a color. Also gets the alpha value of the color if the value param is omitted
 * @param color The color with the targeted opacity/alpha channel.
 * @param value The value to apply to the opacity channel. The value is between [0,1]
 * @returns color The resulting color. Returns an 8 character hex code.
 */
export declare const alpha: (color: Color, value?: number) => Color | number;
/**
 * @function
 * @description Darkens the color by reducing the lightness channel. .
 * @param   color The color to darken.
 * @param amount The amount to darken with. Also supports expressions as strings e.g darken("#fc23a1","*0.5")
 * @param mode The color space to compute the color in. Any color space with a lightness channel will do (including HWB)
 * @returns color The darkened color.
 */
export declare const darken: (color: Color, amount: number) => Color;
/**
 *
 * @param color The color to brighten.
 * @param amount The amount to brighten with. Also supports expressions as strings e.g darken("#fc23a1","*0.5")
 * @param mode The color space to compute the color in. Any color space with a lightness channel will do (including HWB)
 * @returns
 */
export declare const brighten: (color: Color, amount: number | string) => Color;
/**
 * @function
 * @description Gets the  value specifified channel on the color.
 * @param mc The mode and channel to be retrieved. For example "rgb.b" will return the value of the blue channel in the RGB color space of that color.
 * @param color The color being queried.
 * @returns value The value of the queried channel.
 * */
export declare const getChannel: (mc: string) => (color: Color) => number;
/** @alias
 * Gets the luminance value of that color as defined by WCAG.
 * @param color The color to query.
 * @returns value The color's luminance value.
 */
export declare const getLuminance: (color: Color) => number;
declare const luminance: (color: any, lum: any) => any;
/**
 * @function
 *  Returns the RGB color equivalent of any number between 0 and 16,777,215.
 * @param num The number to convert to RGB
 * @returns color An RGB color object or hex string.
 */
export declare const num2rgb: (num: number, hex?: boolean) => Color;
/**
 * @function
 * Returns the numerical equivalent of a color.
 * @param color The color to convert to its numerical equivalent.
 * @returns value The numerical value of the color from 0 to 16,777,215.
 */
export declare const rgb2num: (color: Color) => number;
declare const rgb2temperature: (color: Color) => number;
/**
 * @function
 *Sets the value for the specified channel in a color.
 * @param  color Any recognizable color token.
 * @param  mc The mode and channel to work with. For example 'rgb.b'.
 * @param  value The value to set on the queried channel. Also supports expressions as strings e.g set('lch.c)("#fc23a1","*0.5")
 * @returns color The mutated color.
 */
export declare const setChannel: (mc: string) => (color: Color, value: number | string) => Color;
declare const temperature2rgb: (kelvin: number) => Color;
/**Wrapper function that returns TailwindCSS color value(s) of the specified shade. If invoked with no parameters it returns an array of colors from 100 to 900. If invoked with parameter will return the specified shade vale,
 * @param  val The tone value of the shade. Values are in incrementals of 100. Both numeric (100) and its string equivalent ('100') are valid.
 * @returns color A hex string value or array of hex strings.
 *
 */
export declare const tailwindColors: (shade: keyof HueMap) => (val?: keyof ScaleValues) => string | string[];
/**
 * @function
 *  Checks if a color is achromatic(without hue or simply grayscale).
 * @param color The color to test if it is achromatic or not.
 * @returns boolean Returns true if the color is achromatic else false
 */
export declare const isAchromatic: (color: Color) => boolean;
/**
 * @function
 * A wrapper function for the default Tailwind palette. If called with both parameters it return the hex code at the specified shade and value. Else, if called with the shade parameter as "all" it will return all colors from the shades in the palette map at the specified value (if value is undefined it will default to "500"). When called with the shade parameter only it will return all the colors from 100 to 900 of the specified shade.
 * @param shade Any shade in the default TailwindCSS palette e.g amber,blue.
 * @param val Any value from 100 to 900 in increments of 100 e.g "200".
 * @returns color Returns a hex code string or array of hex codes depending on how the function is called.
 */
export declare const colors: (shade: keyof HueMap, val: keyof ScaleValues) => any[] | "#000000";
/**
 * @function
 * @description Checks if a color can be roughly classified as a cool color. Returns true if color is a cool color else false.
 * @param color The color to check the temperature.
 * @returns True or false.
 */
export declare const isCool: (color: Color) => boolean;
/**
 * @function
 * @description Checks if a color can be roughly classified as a warm color. Returns true if color is a warm color else false.
 * @param color The color to check the temperature.
 * @returns True or false.
 */
export declare const isWarm: (color: Color) => boolean;
/**
 * @function
 * @description Generates a randomised classic color scheme from a single base color.
 * @param  scheme {"analogous"|"triadic"|"tetradic"|"complementary"|"splitComplementary"} Any classic color scheme either
 * @param hex Optional boolen to return lch color objects or hex codes in the result array. Default is false  which returns LCH color objects.
 * @returns An array of 8 character hex codes. Elements in the array depend on the number of sample colors in the targeted scheme.
 */
export declare const base: (scheme: palette) => (color: Color, hex?: boolean) => string[] | import("lodash").Dictionary<any>[];
/**
 *  @function
 * Returns an array of colors in the specified luminance range. The range is normalised to [0,1].
 * @param  colors The array of colors to filter.
 * @param  startLuminance The minimum end of the luminance range.
 * @param  endLuminance The maximum end of the luminance range.
 * @returns Array of filtered colors.
 */
export declare const filterByLuminance: filterBy;
/**
 * @function
 * Returns an array of colors in the specified temperature range between 0 and 30,000 Kelvins.
 * @param colors The array of colors to filter.
 * @param  startTemp The minimum end of the temperature range.
 * @param  endTemp The maximum end of the temperature range.
 * @returns  Array of the filtered colors.
 * @see Based on Neil Bartlett's implementation https://github.com/neilbartlett/color-temperature
 */
export declare const filterByTemp: filterBy;
/**
 * @function
 * Returns colors in the specified hue ranges between 0 to 360.
 * @param colors The array of colors to filter.
 * @param  startHue The minimum end of the hue range.
 * @param  endHue The maximum end of the hue range.
 * @returns  Array of the filtered colors.
 */
export declare const filterByHue: filterBy;
/**
 *  @function
 * Returns an array of colors in the specified saturation range. The range is normalised to [0,1].
 * @param  colors The array of colors to filter.
 * @param  startSaturation The minimum end of the saturation range.
 * @param  endSaturation The maximum end of the saturation range.
 * @returns Array of filtered colors.
 */
export declare const filterBySaturation: filterBy;
/**
 * @function
 * Sorts colors according to temperature value in Kelvins according to the temperature scale in Chroma.temperature(). Achromatic colors may return awkward results.
 * @param  colors The array of colors to sort
 * @param {'warm'|'cool'} order The expected order of arrangement. Either 'asc' or 'desc'. Default is ascending ('asc')
 * @returns [colors] An array of the sorted color values.
 * @see Based on Neil Bartlett's implementation https://github.com/neilbartlett/color-temperature
 */
export declare const sortByTemp: sortBy;
/**
 * Sorts colors according to the relative brightness as defined by WCAG definition.
 * @param {Array<string>} colors The array of colors to sort
 * @param {string} order The expected order of arrangement. Either 'asc' or 'desc'. Default is ascending ('asc')
 * @returns [colors] An array of the sorted color values.
 * @see Uses chroma.luminance() https://vis4.net/chroma-js/#color-luminance
 */
export declare const sortByLuminance: sortBy;
export declare const sortBySaturation: sortBy;
/**
 * @function
 *  * Sorts colors according to hue values. It works with any color space with a hue channel. Note that hue values between HSL and Lch do not align. Achromatic colors are not supported
 * @param  colors The array of colors to sort
 * @param order The expected order of arrangement. Either 'asc' or 'desc'. Default is ascending ('asc')
 * @returns  An array of the sorted color values.
 * @param mode The color space to compute the color distances in. All colors within the collection will be converted to mode. Also note that because differences in hue mapping certain color spaces such as HSL and LCH hue values do not align. Keep such quirks in mind to avoid weird results.
 */
export declare const sortByHue: sortBy;
declare const pastelMapper: (color: Color, hex?: boolean) => Color;
declare const hueshift: (color: Color, opts?: {}, hex?: boolean) => Color[];

export {
	hueshift as hueShift,
	luminance as setLuminance,
	pastelMapper as pastel,
	rgb2temperature as getTemp,
	temperature2rgb as setTemp,
};

export {};
